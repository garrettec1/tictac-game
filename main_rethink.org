* This Branch
** Big problems
   - Reliance on turn counter
     Relying on the turn counter is problematic because it increases complexity
     and greatly decreases my ability to alter the code without serious
     ramifications
   - win_block
     I structured win_block to return a move that would fail the legal move test
     and then run again to find a blocking move. This worked great for the
     current implimentation of the code, but is not reuseable in any way shape or
     form. I might be able to fix this, but it does not solve the more
     fundemental issues inherent in the code.
   - AI
     The computer AI is flawed. Again, fixable, but does not solve overall issues
     with complexity and readability
** Solution?
   - I need to gut the AI, and fundamentally change the way the human and computer
     interact with the board. They should interface with the board in the same
     way. This will make things clearer.
   - Also I need some kind of algorithm that will do the move decisions for the
     computer 100% regardless of the state of the board. Not sure how to go
     about that, but one problem at a time.
* Initial thoughts:
  Okay, going to try some things to see if I can make main more readable.
  I am going to start by making a detect tie function, as main is currently
  structured, I need to call it twice, as the game can become tied after either
  player moves.
  Next I am going to try to functionalize the move sets. I gain a tiny tiny
  amount of efficiency by not checking for wins every move, but it might be
  worthwhile from the point of view of readability to forgo that. I will get
  some advice on it. Maybe I will make a branch version!

* Second thoughts:
** first_turn
  I want to change this more than I initially expected.
  There are two possible piece states:
    1. Computer goes first
       - computer = 'X'
       - human    = 'O'
    2. Human goes first
       - human    = 'X'
       - computer = 'O'
  I am currently using first_turn in an awkward way, and only once.
  I can actually use the piece assignment to determine who goes when.
** turn_count
   While turn_count is useful to determine how far along the game is, it's
   awkward that I am using it to control the main while and determine game state.

   This is why I have break statements. Because turn becoming 10 does not
   actually stop the game.

   I propose controlling the while with a Boole like continue_game:

** Game phases
   There are a couple of phases I am paying attention to in the game.
   1) turns 1-4
      * first move
      * NO POSSIBLE WINS OR TIES
   2) turns 5-9
      * Possible winning or blocking moves
   3) turn 10
      * Possible win
      * Possible tie
   I could...
   1) ignore some differences and squash phases together
   2) actually detect ties
   3) make a individual function for each "goes first"
   4) find a better solution. I want the game to be impervious to who is going
      first. I want to find a way to make that happen.

* simplest case mock: two while loops
  while (first_turn == "human"):
    ... code for human first game here...
    first_turn = "false"
  while (first_turn == "computer"):
    ... code for computer first game here...
    first_turn = "stop"
** Problems with this.
   1) Using first_turn to enter and end the loop might be confusing.
      - I could change the name?
   2) A lot of code duplication. Which is why I rejected something like this
      initially when writing this.
      - Proper functions should greatly decrease the amount of repetitious code
        and increase readability.
   3) Not ideal because it is not really insensitive to who goes first, it just
      handles the problem in a more straightforward fashion.
        - This is code I can write right now, and may illuminate a better
          solution overall. I will go for it.
